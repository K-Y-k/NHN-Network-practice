= Broker ν΄λμ¤ μƒμ„Έ μ„¤λ…

* Broker ν΄λμ¤λ” MQTT λΈλ΅μ»¤ μ—­ν• μ„ μν–‰ν•λ©°, ν΄λΌμ΄μ–ΈνΈμ™€ μ—°κ²°μ„ μ μ§€ν•λ©΄μ„ λ©”μ‹μ§€λ¥Ό μ†΅μμ‹ ν•λ” κΈ°λ¥μ„ μ κ³µν•©λ‹λ‹¤.
* λ©€ν‹°μ¤λ λ”©μ„ μ§€μ›ν•μ—¬ μ—¬λ¬ ν΄λΌμ΄μ–ΈνΈκ°€ λ™μ‹μ— μ—°κ²°ν•  μ μλ„λ΅ μ„¤κ³„λμ—μµλ‹λ‹¤.
* ν΄λΌμ΄μ–ΈνΈμ μ—°κ²° μ”μ²­, κµ¬λ… κ΄€λ¦¬, λ©”μ‹μ§€ μ „λ‹¬ λ° PING μ”μ²­ μ²λ¦¬ λ“±μ κΈ°λ¥μ„ ν¬ν•¨ν•©λ‹λ‹¤.

== 1. μ£Όμ” μ—­ν• 
* ν΄λΌμ΄μ–ΈνΈμ™€μ μ—°κ²° κ΄€λ¦¬
** ν΄λΌμ΄μ–ΈνΈμ CONNECT μ”μ²­μ„ μ²λ¦¬ν•κ³ , μ—°κ²° μ μ§€.
** ν΄λΌμ΄μ–ΈνΈκ°€ μ—°κ²° μΆ…λ£(DISCONNECT) μ‹, κ΄€λ ¨ μμ› μ •λ¦¬.

* ν† ν”½ κΈ°λ°μ λ©”μ‹μ§€ λ°ν–‰ λ° κµ¬λ… κ΄€λ¦¬
** SUBSCRIBE μ”μ²­μ„ μ²λ¦¬ν•μ—¬ ν΄λΌμ΄μ–ΈνΈκ°€ νΉμ • ν† ν”½μ„ κµ¬λ…ν•  μ μλ„λ΅ ν•¨.
** UNSUBSCRIBE μ”μ²­μ„ μ²λ¦¬ν•μ—¬ ν΄λΌμ΄μ–ΈνΈμ κµ¬λ…μ„ ν•΄μ .
** PUBLISH λ©”μ‹μ§€λ¥Ό μμ‹ ν•λ©΄, ν•΄λ‹Ή ν† ν”½μ„ κµ¬λ… μ¤‘μΈ λ¨λ“  ν΄λΌμ΄μ–ΈνΈμ—κ² λ©”μ‹μ§€λ¥Ό μ „λ‹¬.

* PING λ° μ‘λ‹µ κ΄€λ¦¬
** ν΄λΌμ΄μ–ΈνΈμ PINGREQ λ©”μ‹μ§€λ¥Ό μ²λ¦¬ν•κ³  PINGRESP μ‘λ‹µμ„ λ°ν™.


== 2. μ£Όμ” ν•„λ“

[source,java]
----
private final Map<String, List<ClientHandler>> topicSubscribers = new ConcurrentHashMap<>();
private final ExecutorService executorService = Executors.newFixedThreadPool(10);
private int port;
----

[cols="1a,4a"]
|===
^s| ν•„λ“ ^s| μ„¤λ…
^s| **topicSubscribers** | ν† ν”½λ³„ κµ¬λ… μ¤‘μΈ ν΄λΌμ΄μ–ΈνΈ λ©λ΅μ„ μ €μ¥ν•λ” λ§µ (**ConcurrentHashMap** ν™μ©).
^s| **executorService** | μ¤λ λ“ ν’€μ„ μ‚¬μ©ν•μ—¬ ν΄λΌμ΄μ–ΈνΈ μ—°κ²°μ„ λΉ„λ™κΈ°μ μΌλ΅ μ²λ¦¬.
^s| **port** | λΈλ΅μ»¤κ°€ μμ‹  λ€κΈ°ν•  ν¬νΈ λ²νΈ.
|===



== 3. μƒμ„±μ
[source,java]
----
public Broker(int port) {
    this.port = port;
}
----

=== κΈ°λ¥
* MQTT λΈλ΅μ»¤ μΈμ¤ν„΄μ¤λ¥Ό μƒμ„±ν•κ³ , ν•΄λ‹Ή ν¬νΈμ—μ„ ν΄λΌμ΄μ–ΈνΈμ μ—°κ²° μ”μ²­μ„ μμ‹ ν•  μ¤€λΉ„λ¥Ό ν•¨.

== 4. λΈλ΅μ»¤ μ‹¤ν–‰ (**run()** λ©”μ„λ“)
[source,java]
----
@Override
public void run() {
    try (ServerSocket serverSocket = new ServerSocket(port)) {
        log.info("MQTT Broker started on port: {}", port);

        while (!Thread.currentThread().isInterrupted()) {
            Socket clientSocket = serverSocket.accept();
            executorService.submit(new ClientHandler(clientSocket));
        }
    } catch (IOException e) {
        log.warn(e.getMessage());
    } finally {
        executorService.shutdownNow();
    }
}
----


=== π”Ή κΈ°λ¥
* **ServerSocket**μ„ μƒμ„±ν•μ—¬ ν¬νΈμ—μ„ ν΄λΌμ΄μ–ΈνΈ μ—°κ²°μ„ λ€κΈ°.
* ν΄λΌμ΄μ–ΈνΈκ°€ μ—°κ²° μ”μ²­μ„ λ³΄λ‚΄λ©΄ ClientHandlerλ¥Ό μ¤λ λ“ ν’€μ—μ„ μ‹¤ν–‰ν•μ—¬ λΉ„λ™κΈ° μ²λ¦¬.
* μ¤λ λ“κ°€ μΈν„°λ½νΈ λλ©΄ μΆ…λ£(**shutdownNow()** νΈμ¶).



== 5. κµ¬λ… κ΄€λ¦¬

=== 5.1 **subscribe()** - νΉμ • ν† ν”½μ„ κµ¬λ…

[source,java]
----
public void subscribe(ClientHandler client, String topic) {
    topicSubscribers.computeIfAbsent(topic, k -> new CopyOnWriteArrayList<>()).add(client);
    log.info("Client subscribed to topic: {}", topic);
}
----

=== κΈ°λ¥
* ν† ν”½λ³„ κµ¬λ… λ©λ΅μ— ν΄λΌμ΄μ–ΈνΈλ¥Ό μ¶”κ°€.
* κµ¬λ… λ¦¬μ¤νΈκ°€ μ—†μΌλ©΄ μƒλ΅μ΄ λ¦¬μ¤νΈλ¥Ό μƒμ„±.
* **CopyOnWriteArrayList**λ¥Ό μ‚¬μ©ν•μ—¬ λ™μ‹ μ ‘κ·Ό μ•μ „μ„± ν™•λ³΄.


=== 5.2 **unsubscribe()** - νΉμ • ν† ν”½ κµ¬λ… ν•΄μ 
[source,java]
----
public void unsubscribe(ClientHandler client, String topic) {
    topicSubscribers.getOrDefault(topic, new ArrayList<>()).remove(client);
    log.info("Client unsubscribed from topic: {}", topic);
}
----

=== π”Ή κΈ°λ¥
* ν•΄λ‹Ή ν† ν”½μ„ κµ¬λ… μ¤‘μΈ ν΄λΌμ΄μ–ΈνΈ λ¦¬μ¤νΈμ—μ„ μ κ±°.


== 6. λ©”μ‹μ§€ λ°ν–‰ λ° μ „λ‹¬

=== 6.1 **publish()** - νΉμ • ν† ν”½μ— λ©”μ‹μ§€ λ°ν–‰
[source,java]
----
public void publish(String topic, String message) {
    List<ClientHandler> subscribers = topicSubscribers.get(topic);
    if (subscribers != null) {
        for (ClientHandler subscriber : subscribers) {
            subscriber.sendPublish(topic, message);
        }
    }
}
----

=== κΈ°λ¥
* νΉμ • ν† ν”½μ„ κµ¬λ… μ¤‘μΈ λ¨λ“  ν΄λΌμ΄μ–ΈνΈμ—κ² PUBLISH λ©”μ‹μ§€λ¥Ό μ „μ†΅.

== 7. **ClientHandler** ν΄λμ¤ (ν΄λΌμ΄μ–ΈνΈ μ—°κ²° μ²λ¦¬)

[source,java]
----
class ClientHandler implements Runnable {
    private final Socket socket;
    private DataInputStream input;
    private DataOutputStream output;
    private boolean connected = false;
    private int remotePort;

    ...
}
----

[cols="1a,4a"]
|===
^s| ν•„λ“ ^s| μ„¤λ…
^s| **socket** | ν΄λΌμ΄μ–ΈνΈμ™€ μ—°κ²°λ μ†μΌ“ κ°μ²΄.
^s| **input** | ν΄λΌμ΄μ–ΈνΈμ—μ„ μμ‹ λ λ°μ΄ν„° μ¤νΈλ¦Ό.
^s| **output** | ν΄λΌμ΄μ–ΈνΈλ΅ μ „μ†΅ν•  λ°μ΄ν„° μ¤νΈλ¦Ό.
^s| **connected** | ν΄λΌμ΄μ–ΈνΈμ μ—°κ²° μƒνƒλ¥Ό μ¶”μ ν•λ” λ³€μ.
^s| **remotePort** | ν΄λΌμ΄μ–ΈνΈμ ν¬νΈ λ²νΈ.
|===


== 8. ν΄λΌμ΄μ–ΈνΈ μ”μ²­ μ²λ¦¬ (**run()** λ©”μ„λ“)

[source,java]
----
@Override
public void run() {
    log.info("Start : {}", remotePort);
    try {
        while (!Thread.currentThread().isInterrupted()) {
            Message message = receive();
            log.info("Received: {}", message.toString());

            switch (message.getType()) {
                case CONNECT: {
                    // TODO: CONNECT λ©”μ‹μ§€λ¥Ό ν™•μΈν•κ³ , CONNACKλ¥Ό λ°ν™ν•©λ‹λ‹¤.
                    break;
                }

                case PUBLISH: {
                    // TODO: PUBLISH λ©”μ‹μ§€λ¥Ό ν™•μΈν•κ³ , subscriberμ—κ² ν•΄λ‹Ή λ©”μ‹μ§€λ¥Ό μ „μ†΅ν•©λ‹λ‹¤.
                    break;
                }

                case SUBSCRIBE: {
                    // TODO: SUBSCRIBE λ©”μ‹μ§€λ¥Ό ν™•μΈν•κ³ , ν† ν”½ λ“±λ΅ ν›„ SUBACKλ¥Ό μ „μ†΅ν•©λ‹λ‹¤.
                    break;
                }

                case UNSUBSCRIBE: {
                    // TODO: UNSUBSCRIBE λ©”μ‹μ§€λ¥Ό ν™•μΈν•κ³ , ν•΄λ‹Ή ν† ν”½μ„ μ κ±° ν•©λ‹λ‹¤.
                    break;
                }

                case PINGREQ: {
                    // TODO: PINGREG λ©”μ‹μ§€λ¥Ό ν™•μΈν•κ³ , PINGRESPλ¥Ό μ „μ†΅ν•©λ‹λ‹¤.
                    break;
                }

                case DISCONNECT: {
                    log.info("Client disconnected.");
                    socket.close();
                    Thread.currentThread().interrupt();
                    break;
                }

                default: {
                    log.warn("μ§€μ›ν•μ§€ μ•λ” λ…λ Ήμ…λ‹λ‹¤: {}", message.toString());
                }
            }
        }
    } catch (IOException e) {
        log.warn(e.getMessage());
        Thread.currentThread().interrupt();
    } finally {
        closeConnection();
        log.info("Finished : {}", remotePort);
    }
}
----

=== κΈ°λ¥
* ν΄λΌμ΄μ–ΈνΈλ΅λ¶€ν„° λ©”μ‹μ§€λ¥Ό μμ‹ ν•κ³  μ μ ν• μ‘λ‹µμ„ μ „μ†΅.
* CONNECT, PUBLISH, SUBSCRIBE, UNSUBSCRIBE, PINGREQ, DISCONNECT λ“±μ λ©”μ‹μ§€λ¥Ό μ²λ¦¬.

== 9. ν΄λΌμ΄μ–ΈνΈλ΅ λ©”μ‹μ§€ μ „μ†΅ (**send()** λ©”μ„λ“)
[source,java]
----
public void send(Message message) {
    try {
        output.write(message.toByteArray());
        output.flush();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
----

=== κΈ°λ¥
* MQTT λ©”μ‹μ§€λ¥Ό λ°”μ΄νΈ λ°°μ—΄λ΅ λ³€ν™ν•μ—¬ μ „μ†΅.

== 10. **receive()** - ν΄λΌμ΄μ–ΈνΈλ΅λ¶€ν„° λ©”μ‹μ§€ μμ‹ 
[source,java]
----
protected synchronized Message receive() throws IOException {
    byte[] header = new byte[5];
    input.readFully(header, 0, 2);

    int lengthFieldCount = 1;
    int length = header[lengthFieldCount] & 0x7F;
    while ((lengthFieldCount < 4) && ((header[lengthFieldCount] & 0x80) == 0x80)) {
        lengthFieldCount++;
        input.readFully(header, lengthFieldCount, 1);
        length += (int) ((header[lengthFieldCount] & 0x7F) * Math.pow(128, lengthFieldCount - 1.0));
    }

    byte[] buffer = Arrays.copyOf(header, 1 + lengthFieldCount + length);
    input.readFully(buffer, 1 + lengthFieldCount, length);

    return Message.parsing(buffer);
}
----

=== κΈ°λ¥
* MQTT λ©”μ‹μ§€λ¥Ό μμ‹ ν•κ³  νμ‹±ν•μ—¬ **Message** κ°μ²΄λ΅ λ³€ν™.
